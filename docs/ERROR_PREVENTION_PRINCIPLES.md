# Error Prevention Principles

이 문서는 이 프로젝트에서 실제로 발생했던 장애/오류를 기준으로, 같은 문제가 다시 생기지 않도록 지켜야 할 원칙을 정리합니다.

## (운영) 새 오류를 기록하는 템플릿

새로운 오류/장애가 나오면 아래 템플릿을 복사해서 이 문서에 추가합니다.

### [YYYY-MM-DD] 제목 (한 줄 요약)

- **증상**: 사용자에게 보인 현상/에러 메시지
- **재현 조건**: 언제/어떤 데이터/어떤 탭/온라인·오프라인 등
- **원인**: 코드/상태/환경/제약(스키마 등) 중 무엇이 트리거였는지
- **해결**: 어떤 수정으로 해결했는지(파일/모듈 기준)
- **재발 방지 원칙**: 앞으로 지켜야 할 규칙 1~3개 (테스트/린트/가드 포함)
- **체크리스트**: PR 리뷰 때 확인할 항목(짧게)

## 1) React 렌더링 안정성

### 1-1. Hook 규칙(React 310) 절대 위반 금지

증상:

- 특정 조건(대용량 플랜, 로딩 지연 등)에서만 간헐적으로 React minified error 310(= Rendered more hooks than during the previous render 계열)이 발생

원인 패턴:

- `if (...) return ...` 같은 early return 뒤에서 `useMemo`, `useEffect` 등 Hook을 호출
- 데이터가 “나중 렌더”에 채워지는 경우(대용량/네트워크/캐시) 첫 렌더와 이후 렌더의 Hook 호출 개수가 달라짐

원칙:

- Hook은 항상 컴포넌트 최상단에서, 조건 없이 동일한 순서로 호출
- 로딩/미존재 상태 처리(`return ...`)가 필요하면, Hook에서 안전한 기본값을 반환하도록 만들고 렌더는 그 값으로 처리

실제 적용 예:

- 진도율 탭에서 `progress`가 없을 때도 `useMemo`가 동일하게 호출되도록 변경

### 1-2. 대용량 데이터는 “느리게 도착할 수 있음”을 전제로 UI 작성

원칙:

- plan/progress 같은 데이터는 “초기 렌더에 없고 다음 렌더에 생길 수 있다”는 전제로 작성
- 로딩 상태와 성공 상태의 UI 분기는 가능하지만, Hook 호출 순서는 변하면 안 됨

## 2) PWA/Service Worker 안정성

### 2-1. 오프라인에서 SW 업데이트 실패는 치명적 오류로 취급하지 않음

증상:

- 오프라인에서 SW 업데이트 fetch 실패가 발생
- 이후 온라인 복귀 시 앱이 크래시하거나 DOM 예외가 연쇄적으로 발생할 수 있음

원칙:

- `navigator.onLine === false` 일 때는 SW update 시도를 하지 않거나, 실패를 사용자에게 치명적으로 노출하지 않음
- 온라인 복귀(`online` 이벤트) 시점에 update를 재시도

### 2-2. SW 관련 오류와 앱 런타임 오류를 분리

원칙:

- SW 등록/업데이트는 앱 핵심 UI와 분리된 모듈에서 처리
- SW 업데이트 실패를 전역 fatal 처리로 연결하지 않음(네트워크 환경에 따라 정상적으로 발생 가능)

## 3) 전역 오류(에러 오버레이) 처리

### 3-1. React가 관리하는 `#root` DOM을 직접 수정하지 않음

증상:

- 전역 오류 화면이 `#root`를 덮어쓰거나 내부 DOM을 변경
- 이후 React가 언마운트/리렌더 과정에서 `removeChild` 같은 DOM 예외 발생

원칙:

- 전역 에러 UI는 `document.body` 아래에 별도 오버레이 컨테이너를 만들어 표시
- `#root`는 React 전용 영역으로 유지

### 3-2. “일시 장애”는 복구 시도를 한 번만 수행

증상:

- 배포 직후 캐시 혼합/청크 불일치로 동적 import(chunks) 로드 실패가 발생

원칙:

- 청크/동적 import 실패로 판단되는 오류는 1회 자동 reload로 복구 시도
- 무한 루프 방지를 위해 “1회만” 수행(플래그 사용)

## 4) 데이터/DB 제약 기반 방어

### 4-1. DB 스키마 제약(문자열 길이)을 클라이언트에서도 준수

사실:

- DB `plans.name`는 `VARCHAR(255)`

증상:

- 선택한 책을 모두 나열하는 자동 이름(예: `(창세기, ..., 말라기, 마태복음, ...)`)이 255자를 초과
- 서버에서 insert/update가 실패하여 “계획 생성 불가”로 보임

원칙:

- 입력 UI에서 `maxLength` 등으로 사전 제한
- 자동 생성 이름은 “요약형”으로 생성
  - 예: `성경 전체 (66권)`, `구약 전체 (39권)`, `신약 전체 (27권)`, `창세기 ~ 말라기 (39권)`
- 서버 에러 메시지는 사용자가 이해할 수 있도록 클라이언트에서 선제 검증

## 5) 테스트/검증 원칙(로컬)

원칙:

- 재발 가능성이 큰 영역(전역 에러 처리, SW 업데이트 흐름 등)은 최소한의 단위 테스트로 안전장치 유지
- 협업 정책상 테스트를 원격 저장소에 올리지 않는 경우, 로컬 ignore 정책을 사용해 실수로 커밋되는 것을 방지

## 6) 변경 시 체크리스트

- Hook 호출이 조건에 따라 달라지지 않는가
- 전역 에러 처리 코드가 `#root`를 수정하지 않는가
- 오프라인/온라인 전환 시 SW 업데이트가 안전하게 처리되는가
- 자동 생성 문자열이 DB 제약(길이)을 넘지 않는가
- 청크 로드 실패 복구 로직이 무한 reload 루프를 만들지 않는가
